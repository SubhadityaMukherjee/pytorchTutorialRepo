{"version":3,"sources":["../src/index.ts"],"names":["Private","Drag","options","_this","this","_onScrollFrame","_scrollTarget","_a","element","edge","distance","d","SCROLL_EDGE_SIZE","f","Math","pow","s","max","round","scrollTop","scrollLeft","requestAnimationFrame","_disposed","_dropAction","_override","_currentTarget","_currentElement","_promise","_resolve","mimeData","dragImage","proposedAction","supportedActions","source","prototype","dispose","event_1","createMouseEvent","dispatchDragLeave","_finalize","Object","defineProperty","start","clientX","clientY","Promise","resolve","_addListeners","_attachDragImage","reject","event","document","dispatchEvent","handleEvent","type","_evtMouseMove","_evtMouseUp","_evtKeyDown","preventDefault","stopPropagation","moveDragImage","style","top","left","_updateCurrentTarget","_updateDragScroll","button","action","dispatchDrop","keyCode","addEventListener","_removeListeners","removeEventListener","target","findScrollTarget","setTimeout","prevTarget","currTarget","prevElem","currElem","elementFromPoint","dispatchDragExit","dispatchDragEnter","dispatchDragOver","_setDropAction","classList","add","pointerEvents","position","body","appendChild","_detachDragImage","parent","parentNode","removeChild","validateAction","overrideCursor","clear","cursor","id","overrideCursorID","DisposableDelegate","remove","supported","actionTable","supportedTable","createEvent","initMouseEvent","window","x","y","parentElement","scrollable","hasAttribute","offsetX","offsetY","pageXOffset","pageYOffset","r","getBoundingClientRect","top_1","right","width","bottom","height","dl","dt","dr","db","min","dsw","scrollWidth","clientWidth","dsh","scrollHeight","clientHeight","shouldScroll","drag","dragEvent","createDragEvent","canceled","dropAction","none","copy","link","move","copy-link","copy-move","link-move","all","related","screenX","screenY","ctrlKey","altKey","shiftKey","metaKey"],"mappings":"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","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  MimeData\n} from '@lumino/coreutils';\n\nimport {\n  DisposableDelegate, IDisposable\n} from '@lumino/disposable';\n\n\n/**\n * A type alias which defines the possible independent drop actions.\n */\nexport\ntype DropAction = 'none' | 'copy' | 'link' | 'move';\n\n\n/**\n * A type alias which defines the possible supported drop actions.\n */\nexport\ntype SupportedActions = DropAction | 'copy-link' | 'copy-move' | 'link-move' | 'all';\n\n\n/**\n * A custom event type used for drag-drop operations.\n *\n * #### Notes\n * In order to receive `'lm-dragover'`, `'lm-dragleave'`, or `'lm-drop'`\n * events, a drop target must cancel the `'lm-dragenter'` event by\n * calling the event's `preventDefault()` method.\n */\nexport\ninterface IDragEvent extends MouseEvent {\n  /**\n   * The drop action supported or taken by the drop target.\n   *\n   * #### Notes\n   * At the start of each event, this value will be `'none'`. During a\n   * `'lm-dragover'` event, the drop target must set this value to one\n   * of the supported actions, or the drop event will not occur.\n   *\n   * When handling the drop event, the drop target should set this\n   * to the action which was *actually* taken. This value will be\n   * reported back to the drag initiator.\n   */\n  dropAction: DropAction;\n\n  /**\n   * The drop action proposed by the drag initiator.\n   *\n   * #### Notes\n   * This is the action which is *preferred* by the drag initiator. The\n   * drop target is not required to perform this action, but should if\n   * it all possible.\n   */\n  readonly proposedAction: DropAction;\n\n  /**\n   * The drop actions supported by the drag initiator.\n   *\n   * #### Notes\n   * If the `dropAction` is not set to one of the supported actions\n   * during the `'lm-dragover'` event, the drop event will not occur.\n   */\n  readonly supportedActions: SupportedActions;\n\n  /**\n   * The mime data associated with the event.\n   *\n   * #### Notes\n   * This is mime data provided by the drag initiator. Drop targets\n   * should use this data to determine if they can handle the drop.\n   */\n  readonly mimeData: MimeData;\n\n  /**\n   * The source object of the drag, as provided by the drag initiator.\n   *\n   * #### Notes\n   * For advanced applications, the drag initiator may wish to expose\n   * a source object to the drop targets. That will be provided here\n   * if given by the drag initiator, otherwise it will be `null`.\n   */\n  readonly source: any;\n}\n\n\n/**\n * An object which manages a drag-drop operation.\n *\n * A drag object dispatches four different events to drop targets:\n *\n * - `'lm-dragenter'` - Dispatched when the mouse enters the target\n *   element. This event must be canceled in order to receive any\n *   of the other events.\n *\n * - `'lm-dragover'` - Dispatched when the mouse moves over the drop\n *   target. It must cancel the event and set the `dropAction` to one\n *   of the supported actions in order to receive drop events.\n *\n * - `'lm-dragleave'` - Dispatched when the mouse leaves the target\n *   element. This includes moving the mouse into child elements.\n *\n * - `'lm-drop'`- Dispatched when the mouse is released over the target\n *   element when the target indicates an appropriate drop action. If\n *   the event is canceled, the indicated drop action is returned to\n *   the initiator through the resolved promise.\n *\n * A drag operation can be terminated at any time by pressing `Escape`\n * or by disposing the drag object.\n *\n * A drag object has the ability to automatically scroll a scrollable\n * element when the mouse is hovered near one of its edges. To enable\n * this, add the `data-lm-dragscroll` attribute to any element which\n * the drag object should consider for scrolling.\n *\n * #### Notes\n * This class is designed to be used when dragging and dropping custom\n * data *within* a single application. It is *not* a replacement for\n * the native drag-drop API. Instead, it provides an API which allows\n * drag operations to be initiated programmatically and enables the\n * transfer of arbitrary non-string objects; features which are not\n * possible with the native drag-drop API.\n */\nexport\nclass Drag implements IDisposable {\n  /**\n   * Construct a new drag object.\n   *\n   * @param options - The options for initializing the drag.\n   */\n  constructor(options: Drag.IOptions) {\n    this.mimeData = options.mimeData;\n    this.dragImage = options.dragImage || null;\n    this.proposedAction = options.proposedAction || 'copy';\n    this.supportedActions = options.supportedActions || 'all';\n    this.source = options.source || null;\n  }\n\n  /**\n   * Dispose of the resources held by the drag object.\n   *\n   * #### Notes\n   * This will cancel the drag operation if it is active.\n   */\n  dispose(): void {\n    // Do nothing if the drag object is already disposed.\n    if (this._disposed) {\n      return;\n    }\n    this._disposed = true;\n\n    // If there is a current target, dispatch a drag leave event.\n    if (this._currentTarget) {\n      let event = Private.createMouseEvent('mouseup', -1, -1);\n      Private.dispatchDragLeave(this, this._currentTarget, null, event);\n    }\n\n    // Finalize the drag object with `'none'`.\n    this._finalize('none');\n  }\n\n  /**\n   * The mime data for the drag object.\n   */\n  readonly mimeData: MimeData;\n\n  /**\n   * The drag image element for the drag object.\n   */\n  readonly dragImage: HTMLElement | null;\n\n  /**\n   * The proposed drop action for the drag object.\n   */\n  readonly proposedAction: DropAction;\n\n  /**\n   * The supported drop actions for the drag object.\n   */\n  readonly supportedActions: SupportedActions;\n\n  /**\n   * Get the drag source for the drag object.\n   */\n  readonly source: any;\n\n  /**\n   * Test whether the drag object is disposed.\n   */\n  get isDisposed(): boolean {\n    return this._disposed;\n  }\n\n  /**\n   * Start the drag operation at the specified client position.\n   *\n   * @param clientX - The client X position for the drag start.\n   *\n   * @param clientY - The client Y position for the drag start.\n   *\n   * @returns A promise which resolves to the result of the drag.\n   *\n   * #### Notes\n   * If the drag has already been started, the promise created by the\n   * first call to `start` is returned.\n   *\n   * If the drag operation has ended, or if the drag object has been\n   * disposed, the returned promise will resolve to `'none'`.\n   *\n   * The drag object will be automatically disposed when drag operation\n   * completes. This means `Drag` objects are for single-use only.\n   *\n   * This method assumes the left mouse button is already held down.\n   */\n  start(clientX: number, clientY: number): Promise<DropAction> {\n    // If the drag object is already disposed, resolve to `None`.\n    if (this._disposed) {\n      return Promise.resolve('none' as DropAction);\n    }\n\n    // If the drag has already been started, return the promise.\n    if (this._promise) {\n      return this._promise;\n    }\n\n    // Install the document listeners for the drag object.\n    this._addListeners();\n\n    // Attach the drag image at the specified client position.\n    this._attachDragImage(clientX, clientY);\n\n    // Create the promise which will be resolved on completion.\n    this._promise = new Promise<DropAction>((resolve, reject) => {\n      this._resolve = resolve;\n    });\n\n    // Trigger a fake move event to kick off the drag operation.\n    let event = Private.createMouseEvent('mousemove', clientX, clientY);\n    document.dispatchEvent(event);\n\n    // Return the pending promise for the drag operation.\n    return this._promise;\n  }\n\n  /**\n   * Handle the DOM events for the drag operation.\n   *\n   * @param event - The DOM event sent to the drag object.\n   *\n   * #### Notes\n   * This method implements the DOM `EventListener` interface and is\n   * called in response to events on the document. It should not be\n   * called directly by user code.\n   */\n  handleEvent(event: Event): void {\n    switch(event.type) {\n    case 'mousemove':\n      this._evtMouseMove(event as MouseEvent);\n      break;\n    case 'mouseup':\n      this._evtMouseUp(event as MouseEvent);\n      break;\n    case 'keydown':\n      this._evtKeyDown(event as KeyboardEvent);\n      break;\n    default:\n      // Stop all other events during drag-drop.\n      event.preventDefault();\n      event.stopPropagation();\n      break;\n    }\n  }\n\n  /**\n   * Move the drag image element to the specified location.\n   *\n   * This is a no-op if there is no drag image element.\n   */\n  protected moveDragImage(clientX: number, clientY: number): void {\n    if (!this.dragImage) {\n      return;\n    }\n    let style = this.dragImage.style;\n    style.top = `${clientY}px`;\n    style.left = `${clientX}px`;\n  }\n\n  /**\n   * Handle the `'mousemove'` event for the drag object.\n   */\n  private _evtMouseMove(event: MouseEvent): void {\n    // Stop all input events during drag-drop.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Update the current target node and dispatch enter/leave events.\n    this._updateCurrentTarget(event);\n\n    // Update the drag scroll element.\n    this._updateDragScroll(event);\n\n    // Move the drag image to the specified client position. This is\n    // performed *after* dispatching to prevent unnecessary reflows.\n    this.moveDragImage(event.clientX, event.clientY);\n  }\n\n  /**\n   * Handle the `'mouseup'` event for the drag object.\n   */\n  private _evtMouseUp(event: MouseEvent): void {\n    // Stop all input events during drag-drop.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Do nothing if the left button is not released.\n    if (event.button !== 0) {\n      return;\n    }\n\n    // Update the current target node and dispatch enter/leave events.\n    // This prevents a subtle issue where the DOM mutates under the\n    // cursor after the last move event but before the drop event.\n    this._updateCurrentTarget(event);\n\n    // If there is no current target, finalize with `'none'`.\n    if (!this._currentTarget) {\n      this._finalize('none');\n      return;\n    }\n\n    // If the last drop action was `'none'`, dispatch a leave event\n    // to the current target and finalize the drag with `'none'`.\n    if (this._dropAction === 'none') {\n      Private.dispatchDragLeave(this, this._currentTarget, null, event);\n      this._finalize('none');\n      return;\n    }\n\n    // Dispatch the drop event at the current target and finalize\n    // with the resulting drop action.\n    let action = Private.dispatchDrop(this, this._currentTarget, event);\n    this._finalize(action);\n  }\n\n  /**\n   * Handle the `'keydown'` event for the drag object.\n   */\n  private _evtKeyDown(event: KeyboardEvent): void {\n    // Stop all input events during drag-drop.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Cancel the drag if `Escape` is pressed.\n    if (event.keyCode === 27) {\n      this.dispose();\n    }\n  }\n\n  /**\n   * Add the document event listeners for the drag object.\n   */\n  private _addListeners(): void {\n    document.addEventListener('mousedown', this, true);\n    document.addEventListener('mousemove', this, true);\n    document.addEventListener('mouseup', this, true);\n    document.addEventListener('mouseenter', this, true);\n    document.addEventListener('mouseleave', this, true);\n    document.addEventListener('mouseover', this, true);\n    document.addEventListener('mouseout', this, true);\n    document.addEventListener('keydown', this, true);\n    document.addEventListener('keyup', this, true);\n    document.addEventListener('keypress', this, true);\n    document.addEventListener('contextmenu', this, true);\n  }\n\n  /**\n   * Remove the document event listeners for the drag object.\n   */\n  private _removeListeners(): void {\n    document.removeEventListener('mousedown', this, true);\n    document.removeEventListener('mousemove', this, true);\n    document.removeEventListener('mouseup', this, true);\n    document.removeEventListener('mouseenter', this, true);\n    document.removeEventListener('mouseleave', this, true);\n    document.removeEventListener('mouseover', this, true);\n    document.removeEventListener('mouseout', this, true);\n    document.removeEventListener('keydown', this, true);\n    document.removeEventListener('keyup', this, true);\n    document.removeEventListener('keypress', this, true);\n    document.removeEventListener('contextmenu', this, true);\n  }\n\n  /**\n   * Update the drag scroll element under the mouse.\n   */\n  private _updateDragScroll(event: MouseEvent): void {\n    // Find the scroll target under the mouse.\n    let target = Private.findScrollTarget(event);\n\n    // Bail if there is nothing to scroll.\n    if (!this._scrollTarget && !target) {\n      return;\n    }\n\n    // Start the scroll loop if needed.\n    if (!this._scrollTarget) {\n      setTimeout(this._onScrollFrame, 500);\n    }\n\n    // Update the scroll target.\n    this._scrollTarget = target;\n  }\n\n  /**\n   * Update the current target node using the given mouse event.\n   */\n  private _updateCurrentTarget(event: MouseEvent): void {\n    // Fetch common local state.\n    let prevTarget = this._currentTarget;\n    let currTarget = this._currentTarget;\n    let prevElem = this._currentElement;\n\n    // Find the current indicated element at the given position.\n    let currElem = document.elementFromPoint(event.clientX, event.clientY);\n\n    // Update the current element reference.\n    this._currentElement = currElem;\n\n    // If the indicated element changes from the previous iteration,\n    // and is different from the current target, dispatch the exit\n    // event to the target.\n    if (currElem !== prevElem && currElem !== currTarget) {\n      Private.dispatchDragExit(this, currTarget, currElem, event);\n    }\n\n    // If the indicated element changes from the previous iteration,\n    // and is different from the current target, dispatch the enter\n    // event and compute the new target element.\n    if (currElem !== prevElem && currElem !== currTarget) {\n      currTarget = Private.dispatchDragEnter(this, currElem, currTarget, event);\n    }\n\n    // If the current target element has changed, update the current\n    // target reference and dispatch the leave event to the old target.\n    if (currTarget !== prevTarget) {\n      this._currentTarget = currTarget;\n      Private.dispatchDragLeave(this, prevTarget, currTarget, event);\n    }\n\n    // Dispatch the drag over event and update the drop action.\n    let action = Private.dispatchDragOver(this, currTarget, event);\n    this._setDropAction(action);\n  }\n\n  /**\n   * Attach the drag image element at the specified location.\n   *\n   * This is a no-op if there is no drag image element.\n   */\n  private _attachDragImage(clientX: number, clientY: number): void {\n    if (!this.dragImage) {\n      return;\n    }\n    this.dragImage.classList.add('lm-mod-drag-image');\n    /* <DEPRECATED> */\n    this.dragImage.classList.add('p-mod-drag-image');\n    /* </DEPRECATED> */\n    let style = this.dragImage.style;\n    style.pointerEvents = 'none';\n    style.position = 'fixed';\n    style.top = `${clientY}px`;\n    style.left = `${clientX}px`;\n    document.body.appendChild(this.dragImage);\n  }\n\n  /**\n   * Detach the drag image element from the DOM.\n   *\n   * This is a no-op if there is no drag image element.\n   */\n  private _detachDragImage(): void {\n    if (!this.dragImage) {\n      return;\n    }\n    let parent = this.dragImage.parentNode;\n    if (!parent) {\n      return;\n    }\n    parent.removeChild(this.dragImage);\n  }\n\n  /**\n   * Set the internal drop action state and update the drag cursor.\n   */\n  private _setDropAction(action: DropAction): void {\n    action = Private.validateAction(action, this.supportedActions);\n    if (this._override && this._dropAction === action) {\n      return;\n    }\n    switch (action) {\n    case 'none':\n      this._dropAction = action;\n      this._override = Drag.overrideCursor('no-drop');\n      break;\n    case 'copy':\n      this._dropAction = action;\n      this._override = Drag.overrideCursor('copy');\n      break;\n    case 'link':\n      this._dropAction = action;\n      this._override = Drag.overrideCursor('alias');\n      break;\n    case 'move':\n      this._dropAction = action;\n      this._override = Drag.overrideCursor('move');\n      break;\n    }\n  }\n\n  /**\n   * Finalize the drag operation and resolve the drag promise.\n   */\n  private _finalize(action: DropAction): void {\n    // Store the resolve function as a temp variable.\n    let resolve = this._resolve;\n\n    // Remove the document event listeners.\n    this._removeListeners();\n\n    // Detach the drag image.\n    this._detachDragImage();\n\n    // Dispose of the cursor override.\n    if (this._override) {\n      this._override.dispose();\n      this._override = null;\n    }\n\n    // Clear the mime data.\n    this.mimeData.clear();\n\n    // Clear the rest of the internal drag state.\n    this._disposed = true;\n    this._dropAction = 'none';\n    this._currentTarget = null;\n    this._currentElement = null;\n    this._scrollTarget = null;\n    this._promise = null;\n    this._resolve = null;\n\n    // Finally, resolve the promise to the given drop action.\n    if (resolve) {\n      resolve(action);\n    }\n  }\n\n  /**\n   * The scroll loop handler function.\n   */\n  private _onScrollFrame = () => {\n    // Bail early if there is no scroll target.\n    if (!this._scrollTarget) {\n      return;\n    }\n\n    // Unpack the scroll target.\n    let { element, edge, distance } = this._scrollTarget;\n\n    // Calculate the scroll delta using nonlinear acceleration.\n    let d = Private.SCROLL_EDGE_SIZE - distance;\n    let f = Math.pow(d / Private.SCROLL_EDGE_SIZE, 2);\n    let s = Math.max(1, Math.round(f * Private.SCROLL_EDGE_SIZE));\n\n    // Scroll the element in the specified direction.\n    switch (edge) {\n    case 'top':\n      element.scrollTop -= s;\n      break;\n    case 'left':\n      element.scrollLeft -= s;\n      break;\n    case 'right':\n      element.scrollLeft += s;\n      break;\n    case 'bottom':\n      element.scrollTop += s;\n      break;\n    }\n\n    // Request the next cycle of the scroll loop.\n    requestAnimationFrame(this._onScrollFrame);\n  };\n\n  private _disposed = false;\n  private _dropAction: DropAction = 'none';\n  private _override: IDisposable | null = null;\n  private _currentTarget: Element | null = null;\n  private _currentElement: Element | null = null;\n  private _promise: Promise<DropAction> | null = null;\n  private _scrollTarget: Private.IScrollTarget | null = null;\n  private _resolve: ((value: DropAction) => void) | null = null;\n}\n\n\n/**\n * The namespace for the `Drag` class statics.\n */\nexport\nnamespace Drag {\n  /**\n   * An options object for initializing a `Drag` object.\n   */\n  export\n  interface IOptions {\n    /**\n     * The populated mime data for the drag operation.\n     */\n    mimeData: MimeData;\n\n    /**\n     * An optional drag image which follows the mouse cursor.\n     *\n     * #### Notes\n     * The drag image can be any DOM element. It is not limited to\n     * image or canvas elements as with the native drag-drop APIs.\n     *\n     * If provided, this will be positioned at the mouse cursor on each\n     * mouse move event. A CSS transform can be used to offset the node\n     * from its specified position.\n     *\n     * The drag image will automatically have the `lm-mod-drag-image`\n     * class name added.\n     *\n     * The default value is `null`.\n     */\n    dragImage?: HTMLElement;\n\n    /**\n     * The optional proposed drop action for the drag operation.\n     *\n     * #### Notes\n     * This can be provided as a hint to the drop targets as to which\n     * drop action is preferred.\n     *\n     * The default value is `'copy'`.\n     */\n    proposedAction?: DropAction;\n\n    /**\n     * The drop actions supported by the drag initiator.\n     *\n     * #### Notes\n     * A drop target must indicate that it intends to perform one of the\n     * supported actions in order to receive a drop event. However, it is\n     * not required to *actually* perform that action when handling the\n     * drop event. Therefore, the initiator must be prepared to handle\n     * any drop action performed by a drop target.\n     *\n     * The default value is `'all'`.\n     */\n    supportedActions?: SupportedActions;\n\n    /**\n     * An optional object which indicates the source of the drag.\n     *\n     * #### Notes\n     * For advanced applications, the drag initiator may wish to expose\n     * a source object to the drop targets. That object can be specified\n     * here and will be carried along with the drag events.\n     *\n     * The default value is `null`.\n     */\n    source?: any;\n  }\n\n  /**\n   * Override the cursor icon for the entire document.\n   *\n   * @param cursor - The string representing the cursor style.\n   *\n   * @returns A disposable which will clear the override when disposed.\n   *\n   * #### Notes\n   * The most recent call to `overrideCursor` takes precedence.\n   * Disposing an old override has no effect on the current override.\n   *\n   * This utility function is used by the `Drag` class to override the\n   * mouse cursor during a drag-drop operation, but it can also be used\n   * by other classes to fix the cursor icon during normal mouse drags.\n   *\n   * #### Example\n   * ```typescript\n   * import { Drag } from '@lumino/dragdrop';\n   *\n   * // Force the cursor to be 'wait' for the entire document.\n   * let override = Drag.overrideCursor('wait');\n   *\n   * // Clear the override by disposing the return value.\n   * override.dispose();\n   * ```\n   */\n  export\n  function overrideCursor(cursor: string): IDisposable {\n    let id = ++overrideCursorID;\n    document.body.style.cursor = cursor;\n    document.body.classList.add('lm-mod-override-cursor');\n    /* <DEPRECATED> */\n    document.body.classList.add('p-mod-override-cursor');\n    /* </DEPRECATED> */\n    return new DisposableDelegate(() => {\n      if (id === overrideCursorID) {\n        document.body.style.cursor = '';\n        document.body.classList.remove('lm-mod-override-cursor');\n        /* <DEPRECATED> */\n        document.body.classList.remove('p-mod-override-cursor');\n        /* </DEPRECATED> */\n      }\n    });\n  }\n\n  /**\n   * The internal id for the active cursor override.\n   */\n  let overrideCursorID = 0;\n}\n\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * The size of a drag scroll edge, in pixels.\n   */\n  export\n  const SCROLL_EDGE_SIZE = 20;\n\n  /**\n   * Validate the given action is one of the supported actions.\n   *\n   * Returns the given action or `'none'` if the action is unsupported.\n   */\n  export\n  function validateAction(action: DropAction, supported: SupportedActions): DropAction {\n    return (actionTable[action] & supportedTable[supported]) ? action : 'none';\n  }\n\n  /**\n   * Create a left mouse event at the given position.\n   *\n   * @param type - The event type for the mouse event.\n   *\n   * @param clientX - The client X position.\n   *\n   * @param clientY - The client Y position.\n   *\n   * @returns A newly created and initialized mouse event.\n   */\n  export\n  function createMouseEvent(type: string, clientX: number, clientY: number): MouseEvent {\n    let event = document.createEvent('MouseEvent');\n    event.initMouseEvent(type, true, true, window, 0, 0, 0,\n      clientX, clientY, false, false, false, false, 0, null);\n    return event;\n  }\n\n  /**\n   * An object which holds the scroll target data.\n   */\n  export\n  interface IScrollTarget {\n    /**\n     * The element to be scrolled.\n     */\n    element: Element;\n\n    /**\n     * The scroll edge underneath the mouse.\n     */\n    edge: 'top' | 'left' | 'right' | 'bottom';\n\n    /**\n     * The distance from the mouse to the scroll edge.\n     */\n    distance: number;\n  }\n\n  /**\n   * Find the drag scroll target under the mouse, if any.\n   */\n  export\n  function findScrollTarget(event: MouseEvent): IScrollTarget | null {\n    // Look up the client mouse position.\n    let x = event.clientX;\n    let y = event.clientY;\n\n    // Get the element under the mouse.\n    let element: Element | null = document.elementFromPoint(x, y);\n\n    // Search for a scrollable target based on the mouse position.\n    // The null assert in third clause of for-loop is required due to:\n    // https://github.com/Microsoft/TypeScript/issues/14143\n    for (; element; element = element!.parentElement) {\n      // Ignore elements which are not marked as scrollable.\n      let scrollable = element.hasAttribute('data-lm-dragscroll');\n      /* <DEPRECATED> */\n      scrollable = scrollable || element.hasAttribute('data-p-dragscroll');\n      /* </DEPRECATED> */\n      if (!scrollable) {\n        continue;\n      }\n\n      // Set up the coordinate offsets for the element.\n      let offsetX = 0;\n      let offsetY = 0;\n      if (element === document.body) {\n        offsetX = window.pageXOffset;\n        offsetY = window.pageYOffset;\n      }\n\n      // Get the element bounds in viewport coordinates.\n      let r = element.getBoundingClientRect();\n      let top = r.top + offsetY;\n      let left = r.left + offsetX;\n      let right = left + r.width;\n      let bottom = top + r.height;\n\n      // Skip the element if it's not under the mouse.\n      if (x < left || x >= right || y < top || y >= bottom) {\n        continue;\n      }\n\n      // Compute the distance to each edge.\n      let dl = x - left + 1;\n      let dt = y - top + 1;\n      let dr = right - x;\n      let db = bottom - y;\n\n      // Find the smallest of the edge distances.\n      let distance = Math.min(dl, dt, dr, db);\n\n      // Skip the element if the mouse is not within a scroll edge.\n      if (distance > SCROLL_EDGE_SIZE) {\n        continue;\n      }\n\n      // Set up the edge result variable.\n      let edge: 'top' | 'left' | 'right' | 'bottom';\n\n      // Find the edge for the computed distance.\n      switch (distance) {\n      case db:\n        edge = 'bottom';\n        break;\n      case dt:\n        edge = 'top';\n        break;\n      case dr:\n        edge = 'right';\n        break;\n      case dl:\n        edge = 'left';\n        break;\n      default:\n        throw 'unreachable';\n      }\n\n      // Compute how much the element can scroll in width and height.\n      let dsw = element.scrollWidth - element.clientWidth;\n      let dsh = element.scrollHeight - element.clientHeight;\n\n      // Determine if the element should be scrolled for the edge.\n      let shouldScroll: boolean;\n      switch (edge) {\n      case 'top':\n        shouldScroll = dsh > 0 && element.scrollTop > 0;\n        break;\n      case 'left':\n        shouldScroll = dsw > 0 && element.scrollLeft > 0;\n        break;\n      case 'right':\n        shouldScroll = dsw > 0 && element.scrollLeft < dsw;\n        break;\n      case 'bottom':\n        shouldScroll = dsh > 0 && element.scrollTop < dsh;\n        break;\n      default:\n        throw 'unreachable';\n      }\n\n      // Skip the element if it should not be scrolled.\n      if (!shouldScroll) {\n        continue;\n      }\n\n      // Return the drag scroll target.\n      return { element, edge, distance };\n    }\n\n    // No drag scroll target was found.\n    return null;\n  }\n\n  /**\n   * Dispatch a drag enter event to the indicated element.\n   *\n   * @param drag - The drag object associated with the action.\n   *\n   * @param currElem - The currently indicated element, or `null`. This\n   *   is the \"immediate user selection\" from the whatwg spec.\n   *\n   * @param currTarget - The current drag target element, or `null`. This\n   *   is the \"current target element\" from the whatwg spec.\n   *\n   * @param event - The mouse event related to the action.\n   *\n   * @returns The element to use as the current drag target. This is the\n   *   \"current target element\" from the whatwg spec, and may be `null`.\n   *\n   * #### Notes\n   * This largely implements the drag enter portion of the whatwg spec:\n   * https://html.spec.whatwg.org/multipage/interaction.html#drag-and-drop-processing-model\n   */\n  export\n  function dispatchDragEnter(drag: Drag, currElem: Element | null, currTarget: Element | null, event: MouseEvent): Element | null {\n    // If the current element is null, return null as the new target.\n    if (!currElem) {\n      return null;\n    }\n\n    // Dispatch a drag enter event to the current element.\n    let dragEvent = createDragEvent('lm-dragenter', drag, event, currTarget);\n    let canceled = !currElem.dispatchEvent(dragEvent);\n\n    // If the event was canceled, use the current element as the new target.\n    if (canceled) {\n      return currElem;\n    }\n\n    /* <DEPRECATED> */\n    dragEvent = createDragEvent('p-dragenter', drag, event, currTarget);\n    canceled = !currElem.dispatchEvent(dragEvent);\n    if (canceled) {\n      return currElem;\n    }\n    /* </DEPRECATED> */\n\n    // If the current element is the document body, keep the original target.\n    if (currElem === document.body) {\n      return currTarget;\n    }\n\n    // Dispatch a drag enter event on the document body.\n    dragEvent = createDragEvent('lm-dragenter', drag, event, currTarget);\n    document.body.dispatchEvent(dragEvent);\n\n    /* <DEPRECATED> */\n    dragEvent = createDragEvent('p-dragenter', drag, event, currTarget);\n    document.body.dispatchEvent(dragEvent);\n    /* </DEPRECATED> */\n\n    // Ignore the event cancellation, and use the body as the new target.\n    return document.body;\n  }\n\n  /**\n   * Dispatch a drag exit event to the indicated element.\n   *\n   * @param drag - The drag object associated with the action.\n   *\n   * @param prevTarget - The previous target element, or `null`. This\n   *   is the previous \"current target element\" from the whatwg spec.\n   *\n   * @param currTarget - The current drag target element, or `null`. This\n   *   is the \"current target element\" from the whatwg spec.\n   *\n   * @param event - The mouse event related to the action.\n   *\n   * #### Notes\n   * This largely implements the drag exit portion of the whatwg spec:\n   * https://html.spec.whatwg.org/multipage/interaction.html#drag-and-drop-processing-model\n   */\n  export\n  function dispatchDragExit(drag: Drag, prevTarget: Element | null, currTarget: Element | null, event: MouseEvent): void {\n    // If the previous target is null, do nothing.\n    if (!prevTarget) {\n      return;\n    }\n\n    // Dispatch the drag exit event to the previous target.\n    let dragEvent = createDragEvent('lm-dragexit', drag, event, currTarget);\n    prevTarget.dispatchEvent(dragEvent);\n\n    /* <DEPRECATED> */\n    dragEvent = createDragEvent('p-dragexit', drag, event, currTarget);\n    prevTarget.dispatchEvent(dragEvent);\n    /* </DEPRECATED> */\n  }\n\n  /**\n   * Dispatch a drag leave event to the indicated element.\n   *\n   * @param drag - The drag object associated with the action.\n   *\n   * @param prevTarget - The previous target element, or `null`. This\n   *   is the previous \"current target element\" from the whatwg spec.\n   *\n   * @param currTarget - The current drag target element, or `null`. This\n   *   is the \"current target element\" from the whatwg spec.\n   *\n   * @param event - The mouse event related to the action.\n   *\n   * #### Notes\n   * This largely implements the drag leave portion of the whatwg spec:\n   * https://html.spec.whatwg.org/multipage/interaction.html#drag-and-drop-processing-model\n   */\n  export\n  function dispatchDragLeave(drag: Drag, prevTarget: Element | null, currTarget: Element | null, event: MouseEvent): void {\n    // If the previous target is null, do nothing.\n    if (!prevTarget) {\n      return;\n    }\n\n    // Dispatch the drag leave event to the previous target.\n    let dragEvent = createDragEvent('lm-dragleave', drag, event, currTarget);\n    prevTarget.dispatchEvent(dragEvent);\n\n    /* <DEPRECATED> */\n    dragEvent = createDragEvent('p-dragleave', drag, event, currTarget);\n    prevTarget.dispatchEvent(dragEvent);\n    /* </DEPRECATED> */\n  }\n\n  /**\n   * Dispatch a drag over event to the indicated element.\n   *\n   * @param drag - The drag object associated with the action.\n   *\n   * @param currTarget - The current drag target element, or `null`. This\n   *   is the \"current target element\" from the whatwg spec.\n   *\n   * @param event - The mouse event related to the action.\n   *\n   * @returns The `DropAction` result of the drag over event.\n   *\n   * #### Notes\n   * This largely implements the drag over portion of the whatwg spec:\n   * https://html.spec.whatwg.org/multipage/interaction.html#drag-and-drop-processing-model\n   */\n  export\n  function dispatchDragOver(drag: Drag, currTarget: Element | null, event: MouseEvent): DropAction {\n    // If there is no current target, the drop action is none.\n    if (!currTarget) {\n      return 'none';\n    }\n\n    // Dispatch the drag over event to the current target.\n    let dragEvent = createDragEvent('lm-dragover', drag, event, null);\n    let canceled = !currTarget.dispatchEvent(dragEvent);\n\n    // If the event was canceled, return the drop action result.\n    if (canceled) {\n      return dragEvent.dropAction;\n    }\n\n    /* <DEPRECATED> */\n    dragEvent = createDragEvent('p-dragover', drag, event, null);\n    canceled = !currTarget.dispatchEvent(dragEvent);\n    if (canceled) {\n      return dragEvent.dropAction;\n    }\n    /* </DEPRECATED> */\n\n    // Otherwise, the effective drop action is none.\n    return 'none';\n  }\n\n  /**\n   * Dispatch a drop event to the indicated element.\n   *\n   * @param drag - The drag object associated with the action.\n   *\n   * @param currTarget - The current drag target element, or `null`. This\n   *   is the \"current target element\" from the whatwg spec.\n   *\n   * @param event - The mouse event related to the action.\n   *\n   * @returns The `DropAction` result of the drop event.\n   *\n   * #### Notes\n   * This largely implements the drag over portion of the whatwg spec:\n   * https://html.spec.whatwg.org/multipage/interaction.html#drag-and-drop-processing-model\n   */\n  export\n  function dispatchDrop(drag: Drag, currTarget: Element | null, event: MouseEvent): DropAction {\n    // If there is no current target, the drop action is none.\n    if (!currTarget) {\n      return 'none';\n    }\n\n    // Dispatch the drop event to the current target.\n    let dragEvent = createDragEvent('lm-drop', drag, event, null);\n    let canceled = !currTarget.dispatchEvent(dragEvent);\n\n    // If the event was canceled, return the drop action result.\n    if (canceled) {\n      return dragEvent.dropAction;\n    }\n\n    /* <DEPRECATED> */\n    dragEvent = createDragEvent('p-drop', drag, event, null);\n    canceled = !currTarget.dispatchEvent(dragEvent);\n    if (canceled) {\n      return dragEvent.dropAction;\n    }\n    /* </DEPRECATED> */\n\n    // Otherwise, the effective drop action is none.\n    return 'none';\n  }\n\n  /**\n   * A lookup table from drop action to bit value.\n   */\n  const actionTable: { [key: string]: number } = {\n    'none': 0x0,\n    'copy': 0x1,\n    'link': 0x2,\n    'move': 0x4\n  };\n\n  /**\n   * A lookup table from supported action to drop action bit mask.\n   */\n  const supportedTable: { [key: string]: number } = {\n    'none': actionTable['none'],\n    'copy': actionTable['copy'],\n    'link': actionTable['link'],\n    'move': actionTable['move'],\n    'copy-link': actionTable['copy'] | actionTable['link'],\n    'copy-move': actionTable['copy'] | actionTable['move'],\n    'link-move': actionTable['link'] | actionTable['move'],\n    'all': actionTable['copy'] | actionTable['link'] | actionTable['move']\n  };\n\n  /**\n   * Create a new initialized `IDragEvent` from the given data.\n   *\n   * @param type - The event type for the drag event.\n   *\n   * @param drag - The drag object to use for seeding the drag data.\n   *\n   * @param event - The mouse event to use for seeding the mouse data.\n   *\n   * @param related - The related target for the event, or `null`.\n   *\n   * @returns A new object which implements `IDragEvent`.\n   */\n  function createDragEvent(type: string, drag: Drag, event: MouseEvent, related: Element | null): IDragEvent {\n    // Create a new mouse event to use as the drag event. Currently,\n    // JS engines do now allow user-defined Event subclasses.\n    let dragEvent = document.createEvent('MouseEvent');\n\n    // Initialize the mouse event data.\n    dragEvent.initMouseEvent(\n      type, true, true, window, 0,\n      event.screenX, event.screenY,\n      event.clientX, event.clientY,\n      event.ctrlKey, event.altKey,\n      event.shiftKey, event.metaKey,\n      event.button, related\n    );\n\n    // Forcefully add the custom drag event properties.\n    (dragEvent as any).dropAction = 'none';\n    (dragEvent as any).mimeData = drag.mimeData;\n    (dragEvent as any).proposedAction = drag.proposedAction;\n    (dragEvent as any).supportedActions = drag.supportedActions;\n    (dragEvent as any).source = drag.source;\n\n    // Return the fully initialized drag event.\n    return dragEvent as IDragEvent;\n  }\n}\n"]}